<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DNA Resonance - Elements Edition</title>
    <style>
        body {
            margin: 0;
            background: #000;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-family: 'Segoe UI', sans-serif;
            height: 100vh;
        }

        /* Стилі для зірок */
        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            opacity: 0;
            animation: twinkle 5s infinite ease-in-out alternate;
            pointer-events: none;
        }

        @keyframes twinkle {
            0% { opacity: 0; transform: scale(0.3); }
            50% { opacity: 0.7; transform: scale(1); }
            100% { opacity: 0; transform: scale(0.3); }
        }

        /* Динамічні туманності (Аури стихій) */
        .aura {
            position: absolute;
            border-radius: 50%;
            filter: blur(80px);
            z-index: -1;
            opacity: 0.3;
            pointer-events: none;
            animation: drift 25s infinite linear;
        }

        @keyframes drift {
            from { transform: rotate(0deg) translate(30px) rotate(0deg); }
            to { transform: rotate(360deg) translate(30px) rotate(-360deg); }
        }

        canvas {
            display: block;
            z-index: 5;
            filter: drop-shadow(0 0 20px rgba(255, 255, 255, 0.1));
        }

        #ui {
            position: absolute;
            bottom: 10%;
            text-align: center;
            z-index: 10;
        }

        .info-text {
            font-size: 0.8rem;
            letter-spacing: 4px;
            text-transform: uppercase;
            color: rgba(255,255,255,0.6);
        }

        button {
            position: absolute;
            z-index: 100;
            padding: 20px 40px;
            background: none;
            border: 1px solid rgba(255, 255, 255, 0.4);
            color: white;
            border-radius: 50px;
            backdrop-filter: blur(5px);
            cursor: pointer;
            font-size: 1rem;
            transition: 0.3s;
        }

        button:hover {
            background: rgba(255,255,255,0.1);
            border-color: white;
        }
    </style>
</head>
<body>

    <button id="startBtn">АКТИВУВАТИ РЕЗОНАНС</button>

    <div id="ui">
        <div id="display" class="info-text">Очікування сигналу...</div>
    </div>

    <canvas id="flowerCanvas"></canvas>

<script>
    const canvas = document.getElementById('flowerCanvas');
    const ctx = canvas.getContext('2d');
    const startBtn = document.getElementById('startBtn');
    
    // 1. Отримання параметрів
    const urlParams = new URLSearchParams(window.location.search);
    const hue = parseInt(urlParams.get('hue')) || 280;
    const petalsCount = parseInt(urlParams.get('petals')) || 8;
    const ip = urlParams.get('ip') || "0.0.0.0";
    const resonanceFreq = parseInt(urlParams.get('freq')) || 432;
    const element = urlParams.get('element') || "water";

    // 2. Оновлення тексту (пробуємо обидва можливі ID для страховки)
    const uiDisplay = document.getElementById('display') || document.getElementById('ipDisplay');
    if (uiDisplay) {
        uiDisplay.innerText = `IP: ${ip} | ELEMENT: ${element.toUpperCase()}`;
    }

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Конфігурація стихій
    const elementStyles = {
        "fire":  { h: 15,  s: 90, l: 50, speed: 0.03 },
        "earth": { h: 130, s: 40, l: 30, speed: 0.01 },
        "air":   { h: 200, s: 80, l: 70, speed: 0.04 },
        "water": { h: 220, s: 70, l: 40, speed: 0.02 }
    };

    const style = elementStyles[element] || elementStyles.water;

    // Створення космосу
    function initCosmos() {
        for (let i = 0; i < 100; i++) {
            const star = document.createElement('div');
            star.className = 'star';
            const size = Math.random() * 2;
            star.style.width = star.style.height = `${size}px`;
            star.style.left = `${Math.random() * 100}%`;
            star.style.top = `${Math.random() * 100}%`;
            star.style.animationDelay = `${Math.random() * 5}s`;
            document.body.appendChild(star);
        }

        for (let i = 0; i < 3; i++) {
            const aura = document.createElement('div');
            aura.className = 'aura';
            aura.style.width = aura.style.height = `${Math.random() * 400 + 200}px`;
            aura.style.left = `${Math.random() * 70}%`;
            aura.style.top = `${Math.random() * 70}%`;
            aura.style.background = `radial-gradient(circle, hsla(${style.h}, ${style.s}%, ${style.l}%, 0.2) 0%, transparent 70%)`;
            document.body.appendChild(aura);
        }
    }

    let time = 0;
    let isStarted = false;

    function draw() {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const cx = canvas.width / 2;
        const cy = canvas.height / 2;

        ctx.save();
        ctx.translate(cx, cy);

        for (let i = 0; i < petalsCount; i++) {
            ctx.rotate((Math.PI * 2) / petalsCount);
            
            ctx.beginPath();
            const len = (150 + Math.sin(time + i) * 30);
            const grad = ctx.createLinearGradient(0, 0, 0, len);
            grad.addColorStop(0, `hsla(${hue}, 100%, 70%, 0)`);
            grad.addColorStop(0.5, `hsla(${hue}, 100%, 70%, 0.5)`);
            grad.addColorStop(1, `hsla(${hue}, 100%, 70%, 0)`);

            ctx.strokeStyle = grad;
            ctx.lineWidth = 2;
            ctx.moveTo(0, 0);
            ctx.quadraticCurveTo(30, len / 2, 0, len);
            ctx.stroke();
        }

        ctx.restore();
        time += style.speed;
        requestAnimationFrame(draw);
    }

    function playTone() {
        try {
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.frequency.setValueAtTime(resonanceFreq, audioCtx.currentTime);
            gain.gain.setValueAtTime(0, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0.1, audioCtx.currentTime + 2);
            
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
        } catch(e) { console.log("Audio error:", e); }
    }

    startBtn.addEventListener('click', () => {
        isStarted = true;
        playTone();
        startBtn.style.display = 'none';
    });

    initCosmos();
    draw();

    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    });
</script>
</body>
</html>


