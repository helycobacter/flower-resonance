<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; background: #000; overflow: hidden; height: 100vh; display: flex; align-items: center; justify-content: center; }
        canvas { position: absolute; top: 0; left: 0; }
        #ui { position: absolute; z-index: 10; bottom: 40px; text-align: center; width: 100%; pointer-events: none; }
        #startBtn { 
            pointer-events: auto; 
            padding: 15px 40px; 
            background: rgba(255,255,255,0.05); 
            border: 1px solid rgba(255,255,255,0.3); 
            color: #fff; 
            border-radius: 40px; 
            cursor: pointer; 
            backdrop-filter: blur(10px); 
            font-family: sans-serif; 
            letter-spacing: 2px; 
            font-size: 12px;
            transition: 0.3s;
            box-shadow: 0 0 20px rgba(255,255,255,0.1);
        }
        #startBtn:active { transform: scale(0.95); }
    </style>
</head>
<body>
    <div id="ui"><button id="startBtn">START JOURNEY</button></div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const params = new URLSearchParams(window.location.search);
        
        const hue = parseInt(params.get('hue')) || 280;
        const petals = parseInt(params.get('petals')) || 8;
        const freq = parseInt(params.get('freq')) || 432;
        const element = (params.get('element') || "water").toLowerCase();

        const styles = {
            fire:  { h: 10,  s: 100, l: 40, speed: 0.03 },
            earth: { h: 120, s: 60,  l: 25, speed: 0.01 },
            air:   { h: 200, s: 80,  l: 60, speed: 0.04 },
            water: { h: 220, s: 70,  l: 40, speed: 0.02 }
        };
        const stl = styles[element] || styles.water;

        let w, h;
        // Масив для зірок
        const stars = [];
        
        function init() {
            w = canvas.width = window.innerWidth;
            h = canvas.height = window.innerHeight;
            stars.length = 0;
            // Створюємо 150 зірок з різними параметрами
            for(let i=0; i<150; i++) {
                stars.push({
                    x: Math.random() * w,
                    y: Math.random() * h,
                    size: Math.random() * 2,
                    speed: 0.2 + Math.random() * 0.8, // Швидкість руху
                    blinkOffset: Math.random() * 100
                });
            }
        }
        window.addEventListener('resize', init);
        init();

        let t = 0;

        // Функція малювання однієї пелюстки (Лотос)
        function drawPetal(len, width, angle, color, alpha) {
            ctx.save();
            ctx.rotate(angle);
            
            // Сяйво пелюстки (неоновий ефект)
            ctx.shadowBlur = 25;
            ctx.shadowColor = color;
            ctx.strokeStyle = color;
            ctx.globalAlpha = alpha;
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.bezierCurveTo(width, len/3, width, len*2/3, 0, len);
            ctx.bezierCurveTo(-width, len*2/3, -width, len/3, 0, 0);
            ctx.stroke();
            
            // Тонка жилка всередині
            ctx.lineWidth = 1;
            ctx.globalAlpha = alpha * 0.5;
            ctx.beginPath();
            ctx.moveTo(0, 5);
            ctx.lineTo(0, len * 0.7);
            ctx.stroke();
            
            ctx.restore();
        }

        function draw() {
            // 1. Очищення та малювання фону (Аура простору)
            // Використовуємо globalCompositeOperation для насиченості
            ctx.globalCompositeOperation = 'source-over';
            
            const grd = ctx.createRadialGradient(w/2, h/2, 0, w/2, h/2, w);
            grd.addColorStop(0, `hsla(${stl.h}, ${stl.s}%, 15%, 1)`); // Центр
            grd.addColorStop(0.6, `hsla(${stl.h}, ${stl.s}%, 5%, 1)`);
            grd.addColorStop(1, "#000000"); // Краї
            
            ctx.fillStyle = grd;
            ctx.fillRect(0, 0, w, h);

            // 2. Малювання та оновлення зірок (ТЕПЕР ВОНИ РУХАЮТЬСЯ І СВІТЯТЬСЯ)
            ctx.shadowBlur = 10; // Сяйво для зірок
            ctx.shadowColor = "white";
            ctx.fillStyle = "#fff";
            
            stars.forEach(s => {
                // Рух зірок вгору (політ)
                s.y -= s.speed * 0.5;
                if (s.y < 0) { s.y = h; s.x = Math.random() * w; } // Переродження знизу

                // Мерехтіння
                const flicker = 0.3 + Math.abs(Math.sin(t * 2 + s.blinkOffset)) * 0.7;
                
                ctx.globalAlpha = flicker;
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.size, 0, Math.PI*2);
                ctx.fill();
            });
            ctx.shadowBlur = 0; // Скидаємо блюр перед наступними операціями
            ctx.globalAlpha = 1;

            // 3. Малювання Квітки
            ctx.save();
            ctx.translate(w/2, h/2);
            
            // Легкий дрейф квітки (ефект невагомості)
            ctx.translate(Math.sin(t * 0.5) * 5, Math.cos(t * 0.3) * 5);
            ctx.rotate(t * 0.05); // Дуже повільне обертання

            // Використовуємо 'lighter' для змішування кольорів пелюсток (ефект світла)
            ctx.globalCompositeOperation = 'lighter';

            // Малюємо 3 шари пелюсток
            for (let layer = 0; layer < 3; layer++) {
                const scale = 1 - (layer * 0.2);
                // Динамічна довжина (дихання)
                const currentLen = (180 + Math.sin(t + layer) * 20) * scale;
                const currentWidth = 70 * scale;
                const alpha = 0.8 - (layer * 0.2);
                
                for (let i = 0; i < petals; i++) {
                    const angle = (Math.PI * 2 / petals) * i + (layer * 0.1);
                    // Колір трохи зміщується для кожного шару
                    const pColor = `hsla(${hue + layer * 10}, 90%, 65%, 1)`;
                    drawPetal(currentLen, currentWidth, angle, pColor, alpha);
                }
            }

            ctx.restore();

            t += stl.speed;
            requestAnimationFrame(draw);
        }

        // Запуск звуку
        document.getElementById('startBtn').onclick = (e) => {
            const btn = e.target;
            btn.style.opacity = '0';
            setTimeout(() => btn.remove(), 500);
            
            try {
                const ac = new (window.AudioContext || window.webkitAudioContext)();
                const o = ac.createOscillator();
                const g = ac.createGain();
                o.type = 'sine'; // Чистий тон
                o.
